# Function that creates a random genome with N and a random number of chromosomes
function createGenome(N::Int,single_chrom::Bool=false)
    # N is the Number of Genes
    # if single_chrom is true create a Genome with a single chromosome
  
    # The genes are stored in X
    X = collect(1:N)
    # Initialize the Genome G
    G=Vector{Vector{Int}}()
    if single_chrom
      shuffle!(X)
      lin=rand([0,1])
      if lin==1
        pushfirst!(X,0)
        push!(X,0)
      end
      push!(G,X)
      return G
    end
    # Make sure that all the genes are used
    while length(X)!=0
      # Choose random start and stop positions for the chromosome
      if length(X)>1
        start_idx=rand(1:length(X)-1)
        stop_idx=rand(start_idx+1:length(X))
      else
        start_idx=1
        stop_idx=1
      end
      temp=shuffle(X[start_idx:stop_idx])
      deleteat!(X,start_idx:stop_idx)
      # If lin is 1 the chromosome is linear, otherwise it is circular
      lin=rand([0,1])
      if lin==1
        pushfirst!(temp,0)
        push!(temp,0)
      end
      push!(G,temp)
    end
    return G
end

# Function that checks if two genomes are the same
function sameGenome(G1::Vector{Vector{Int}},G2::Vector{Vector{Int}})
    # G1, G2 the two given Genomes
  
    G1=deepcopy(G1)
    G2=deepcopy(G2)
    # Check is each chromose in G2 has an equal chromosome in G1
    for j in 1:length(G2)
      # check is chromosome is linear
      if G2[j][1]==0
        # The corresponding chromosome in G1 could either be the exact copy of the chromosome in G2, or it could be the reversed complement of the chromosome in G2
        idx=findfirst(elt->elt==G2[j],G1)
        if isnothing(idx)
          reverse!(G2[j])
          G2[j]=-G2[j]
          idx=findfirst(elt->elt==G2[j],G1)
        end
        if isnothing(idx)
          return false
        end
      # Chromosome is circular
      else
        # The corresponding chromosome in G1 is could either be the exact copy of the chromosome in G2, or it could be a rotated version of it
        idx=findfirst(elt->G2[j][1] in elt,G1)
        if isnothing(idx)
          idx=findfirst(elt->-G2[j][1] in elt,G1)
          if isnothing(idx)
            return false
          else
            reverse!(G2[j])
            G2[j]=-G2[j]
            start=findfirst(elt->elt==G2[j][1],G1[idx])
          end
        else
          start=findfirst(elt->elt==G2[j][1],G1[idx])
        end
        if isnothing(start)
          return false
        end
        G2[j]=circshift(G2[j], start-1)
      end
      if G2[j]==G1[idx]
        deleteat!(G1,idx)
      end
    end
    # If all the chromosomes in G1 have been used, the two genomes are equal
    if length(G1)==0
      return true
    else
      return false
    end
end

# Function to perform a single random DCJ operation of a Genome
function perform_dcj(genome,single_chrom)
    # genome is the given genome
    # if single_chrom is true the DCJ operation should not add a chromosome to the Genome

    # First Generate the Adjacency Graph
    AG = AdjacencyGraph(genome)
    # Pick two random Adjacencies
    i, j = rand(1:length(AG), 2)
    # If rand(0:1) is 1 perform the DCJ operation on the two randomly picked adjacencies
    # Otherwise perform the DCJ operation on one of the randomly picked adjacencies and (0,0)
    if single_chrom||rand(0:1)==1
        temp=AG[i][2]
        AG[i][2]=AG[j][1]
        AG[j][1]=temp
        # If (0,0) is generated by the DCJ operation delete it
        if(AG[i][1]==0&&AG[i][2]==0)
            deleteat!(AG,i)
        end
        if(AG[j][1]==0&&AG[j][2]==0)
            deleteat!(AG,j)
        end
    else
        # Perfrom the DCJ operation only if both the elements in the adjacency are not zero
        if(AG[i][2]!=0&&AG[i][1]!=0)
            push!(AG,[AG[i][2],0])
            AG[i][2]=0
        end
    end
    return Genome(AG)
end

# Function to randomly generate genomes from a base genome and rates of change
function simulate_genomes(n, rates,single_chrom=false, seed=nothing)
    # n is the number of genes
    # rates is a vector of rates for each generated genome
    # output_file is the file where the output of the function is stored
    # if single_chrom is true the Generated Genomes will only have one chromosome
    # seed is the seed for the random function, for reproducability

    # Set the seed if provided
    if seed !== nothing
        Random.seed!(seed)
    end

    # Randomly Generate the base Genome
    base_genome = createGenome(n,single_chrom)
    genomes = Vector{Vector{Vector{Int}}}()

    # Generate the genomes from the base_genome and given rate
    for rate in rates
        genome = copy(base_genome)
        for inversion in 1:rate
            genome=perform_dcj(genome,single_chrom)
        end
        push!(genomes, genome)
    end
    return base_genome, genomes
end

# Function to randomly generate genomes from a base genome, given number of Genomes
function simulate_genomesGeneral(n, m, single_chrom=false, seed=nothing)
    # n is the number of genes
    # m is the number of generated genomes
    # output_file is the file where the output of the function is stored
    # if single_chrom is true the Generated Genomes will only have one chromosome
    # seed is the seed for the random function, for reproducability

    # Set the seed if provided
    if seed !== nothing
        Random.seed!(seed)
    end

    # Randomly Generate the base Genome
    base_genome = createGenome(n,single_chrom)
    genomes = Vector{Vector{Vector{Int}}}()

    # Generate the genomes from the base_genome and given rate
    for _ in 1:m
        rate=rand(1:n)
        genome = copy(base_genome)
        for inversion in 1:rate
            genome=perform_dcj(genome,single_chrom)
        end
        push!(genomes, genome)
    end

    return base_genome, genomes
end